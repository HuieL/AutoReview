{"name": "ICLR_2017_151.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["OPTIMALITY TIGHTENING", "Frank S. He", "Yang Liu", "Jian Peng"], "emails": ["frankheshibi@gmail.com", "liu301@illinois.edu", "aschwing@illinois.edu", "jianpeng@illinois.edu"], "sections": [{"heading": null, "text": "We propose a novel training algorithm for reinforcement learning which combines the strength of deep Q-learning with a constrained optimization approach to tighten optimality and encourage faster reward propagation. Our novel technique makes deep reinforcement learning more practical by drastically reducing the training time. We evaluate the performance of our approach on the 49 games of the challenging Arcade Learning Environment, and report significant improvements in both training time and accuracy."}, {"heading": "1 INTRODUCTION", "text": "The recent advances of supervised deep learning techniques (LeCun et al., 2015) in computer vision, speech recognition and natural language processing have tremendously improved the performance on challenging tasks, including image processing (Krizhevsky et al., 2012), speech-based translation (Sutskever et al., 2014) and language modeling (Hinton et al., 2012). The core idea of deep learning is to use artificial neural networks to model complex hierarchical or compositional data abstractions and representations from raw input data (Bengio et al., 2013). However, we are still far from building intelligent solutions for many real-world challenges, such as autonomous driving, human-computer interaction and automated decision making, in which software agents need to consider interactions with a dynamic environment and take actions towards goals. Reinforcement learning (Bertsekas & Tsitsiklis, 1996; Powell, 2011; Sutton & Barto, 1998; Kaelbling et al., 1996) studies these problems and algorithms which learn policies to make decisions so as to maximize a reward signal from the environment. One of the promising algorithms is Q-learning (Watkins, 1989; Watkins & Dayan, 1992). Deep reinforcement learning with neural function approximation (Tsitsiklis & Roy, 1997; Riedmiller, 2005; Mnih et al., 2013; 2015), possibly a first attempt to combine deep learning and reinforcement learning, has been proved to be effective on a few problems which classical AI approaches were unable to solve. Notable examples of deep reinforcement learning include human-level game playing (Mnih et al., 2015) and AlphaGo (Silver et al., 2016).\nDespite these successes, its high demand of computational resources makes deep reinforcement learning not yet applicable to many real-world problems. For example, even for an Atari game, the deep Q-learning algorithm (also called deep Q-networks, abbreviated as DQN) needs to play up to hundreds of millions of game frames to achieve a reasonable performance (van Hasselt et al., 2015). AlphaGo trained its model using a database of game records of advanced players and, in addition, about 30 million self-played game moves (Silver et al., 2016). The sheer amount of required computational resources of current deep reinforcement learning algorithms is a major bottleneck for its applicability to real-world tasks. Moreover, in many tasks, the reward signal is sparse and delayed, thus making the convergence of learning even slower.\nHere we propose optimality tightening, a new technique to accelerate deep Q-learning by fast reward propagation. While current deep Q-learning algorithms rely on a set of experience replays, they only consider a single forward step for the Bellman optimality error minimization, which becomes highly inefficient when the reward signal is sparse and delayed. To better exploit long-term high-reward strategies from past experience, we design a new algorithm to capture rewards from both forward and backward steps of the replays via a constrained optimization approach. This encourages faster reward propagation which reduces the training time of deep Q-learning.\nWe evaluate our proposed approach using the Arcade learning environment (Bellemare et al., 2013) and show that our new strategy outperforms competing techniques in both accuracy and training time on 30 out of 49 games despite being trained with significantly fewer data frames."}, {"heading": "2 RELATED WORK", "text": "There have been a number of approaches improving the stability, convergence and runtime of deep reinforcement learning since deep Q-learning, also known as deep Q-network (DQN), was first proposed (Mnih et al., 2013; 2015). DQN combined techniques such as deep learning, reinforcement learning and experience replays (Lin, 1992; Wawrzynski, 2009).\nNonetheless, the original DQN algorithm required millions of training steps to achieve humanlevel performance on Atari games. To improve the stability, recently, double Q-learning was combined with deep neural networks, with the goal to alleviate the overestimation issue observed in Q-learning (Thrun & Schwartz, 1993; van Hasselt, 2010; van Hasselt et al., 2015). The key idea is to use two Q-networks for the action selection and Q-function value calculation, respectively. The greedy action of the target is first chosen using the current Q-network parameters, then the target value is computed using a set of parameters from a previous iteration. Another notable advance is \u201cprioritized experience replay\u201d (Schaul et al., 2016) or \u201cprioritized sweeping\u201d for deep Q-learning. The idea is to increase the replay probability of experience tuples that have a high expected learning progress measured by temporal difference errors.\nIn addition to the aforementioned variants of Q-learning, other network architectures have been proposed. The dueling network architecture applies an extra network structure to learn the importance of states and uses advantage functions (Wang et al., 2015). A distributed version of the deep actor-critic algorithm without experience replay was introduced very recently (Mnih et al., 2016). It deploys multiple threads learning directly from current transitions. The approach is applicable to both value-based and policy-based methods, off-policy as well as on-policy methods, and in discrete as well as in continuous domains. The model-free episodic control approach evaluates state-action pairs based on episodic memory using k-nearest neighbors with hashing functions (Blundell et al., 2016). Bootstrapped deep Q-learning carries out temporally-extended (or deep) exploration, thus leading to much faster learning (Osband et al., 2016).\nOur fast reward propagation differs from all of the aforementioned approaches. The key idea of our method is to propagate delayed and sparse rewards during Q-network training, and thus greatly improve the efficiency and performance. We formulate this propagation step via a constrained program. Note that our program is also different from earlier work on off-policy Q\u2217(\u03bb) algorithms with eligibility traces and n-step Q learning (Munos et al., 2016; Watkins, 1989; Mnih et al., 2016), which have been recently shown to perform poorly when used for training deep Q-networks on Atari games."}, {"heading": "3 BACKGROUND", "text": "Reinforcement learning considers agents which are able to take a sequence of actions in an environment. By taking actions and experiencing at most one scalar reward per action, their task is to learn a policy which allows them to act such that a high cumulative reward is obtained over time.\nMore precisely, consider an agent operating over time t \u2208 {1, . . . , T}. At time t the agent is in an environment state st and reacts upon it by choosing action at \u2208 A. The agent will then observe a new state st+1 and receive a numerical reward rt \u2208 R. Throughout, we assume the set of possible actions, i.e., the set A, to be discrete.\nA well established technique to address the aforementioned reinforcement learning task is Qlearning (Watkins, 1989; Watkins & Dayan, 1992). Generally, Q-learning algorithms maintain an action-value function, often also referred to as Q-function, Q(s, a). Given a state s, the action-value function provides a \u2018value\u2019 for each action a \u2208 A which estimates the expected future reward if action a \u2208 A is taken. The estimated future reward is computed based on the current state s or a series of past states st if available.\nThe core idea of Q-learning is the use of the Bellman equation as a characterization of the optimal future reward function Q\u2217 via a state-action-value function\nQ\u2217(st, a) = E[rt + \u03b3max a\u2032 Q\u2217(st+1, a \u2032)]. (1)\nHereby the expectation is taken w.r.t. the distribution of state st+1 and reward rt obtained after taking action a, and \u03b3 is a discount factor. Intuitively, reward for taking action a plus best future reward should equal the best total return from the current state.\nThe choice of Q-function is crucial for the success of Q-learning algorithms. While classical methods use linear Q-functions based on a set of hand-crafted features of the state, more recent approaches use nonlinear deep neural networks to automatically mine intermediate features from the state (Riedmiller, 2005; Lange & Riedmiller, 2010; Mnih et al., 2013; 2015). This change has been shown to be very effective for many applications of reinforcement learning. However, automatic mining of intermediate representations comes at a price: larger quantities of data and more computational resources are required. Even though it is sometimes straightforward to extract large amounts of data, e.g., when training on video games, for successful optimization, it is crucial that the algorithms operate on un-correlated samples from a dataset D for stability. A technique called \u201cexperience replay\u201d (Lin, 1992; Wawrzynski, 2009) encourages this property and quickly emerged as a standard step in the well-known deep Q-learning framework (Mnih et al., 2013; 2015). Experience replays are stored as a dataset D = {(sj , aj , rj , sj+1)} which contains state-action-reward-future state-tuples (sj , aj , rj , sj+1), including past observations from previous plays.\nThe characterization of optimality given in Eq. (1) combined with an \u201cexperience replay\u201d dataset D results in the following iterative algorithmic procedure (Mnih et al., 2013; 2015): start an episode in the initial state s0; sample a mini-batch of tuples B = {(sj , aj , rj , sj+1)} \u2286 D; compute and fix the targets yj = rj + \u03b3maxaQ\u03b8\u2212(sj+1, a) for each tuple using a recent estimate Q\u03b8\u2212 (the maximization is only considered if sj is not a terminal state); update the Q-function by optimizing the following program w.r.t. the parameters \u03b8 typically via stochastic gradient descent:\nmin \u03b8 \u2211 (sj ,aj ,rj ,sj+1)\u2208B (Q\u03b8(sj , aj)\u2212 yj)2 . (2)\nAfter having updated the parameters of the Q-function we perform an action simulation either choosing an action at random with a small probability , or by following the strategy argmaxaQ\u03b8(st, a) which is currently estimated. This strategy is also called the -greedy policy. We then obtain the actual reward rt. Subsequently we augment the replay memory with the new tuple (st, at, rt, st+1) and continue the simulation until this episode terminates or reaches an upper limit of steps, and we restart a new episode. When optimizing w.r.t. the parameter \u03b8, a recent Q-network is used to compute the target yj = rj + \u03b3maxaQ\u03b8\u2212(sj+1, a). This technique is referred to as \u2018semi-gradient descent,\u2019 i.e., the dependence of the target on the parameter \u03b8 is ignored."}, {"heading": "4 FAST REWARD PROPAGATION VIA OPTIMALITY TIGHTENING", "text": "Investigating the cost function given in Eq. (2) more carefully, we observe that it operates on a set of short one-step sequences, each characterized by the tuple (sj , aj , rj , sj+1). Intuitively, each step encourages an update of the parameters \u03b8, such that the action-value function for the chosen action aj , i.e., Q\u03b8(sj , aj), is closer to the obtained reward plus the best achievable future value, i.e., yj = rj + \u03b3maxaQ(sj+1, a). As we expect from the Bellman optimality equation, it is instructive to interpret this algorithm as propagating reward information from time j + 1 backwards to time j.\nTo understand the shortcomings of this procedure consider a situation where the agent only receives a sparse and delayed reward once reaching a target in a maze. Further let |P | characterize the shortest path from the agents initial position to the target. For a long time, no real reward is available\nand the aforementioned algorithm propagates randomly initialized future rewards. Once the target is reached, real reward information is available. Due to the cost function and its property of propagating reward time-step by time-step, it is immediately apparent that it takes at least an additional O(|P |) iterations until the observed reward impacts the initial state. In the following we propose a technique which increases the speed of propagation and achieves improved convergence for deep Q-learning. We achieve this improvement by taking advantage of longer state-action-reward-sequences which are readily available in the \u201cexperience replay memory.\u201d Not only do we propagate information from time instances in the future to our current state, but also will we pass information from states several steps in the past. Even though we expect to see substantial improvements on sequences where rewards are sparse or only available at terminal states, we also demonstrate significant speedups for situations where rewards are obtained frequently. This is intuitive as the Q-function represents an estimate for any reward encountered in the future. Faster propagation of future and past rewards to a particular state is therefore desirable.\nSubsequently we discuss our technique for fast reward propagation, a new deep Q-learning algorithm that exploits longer state-transitions in experience replays by tightening the optimization via constraints. For notational simplicity, we assume that the environmental dynamics is deterministic, i.e., the new state and the reward are solely determined by the current state and action. It is possible to show that mathematically our proposed approach also approximately works in stochastic environments. Please see details in the appendix. From the Bellman optimality equation we know that the following series of equalities hold for the optimal Q-function Q\u2217:\nQ\u2217(sj , aj) = rj + \u03b3max a Q\u2217(sj+1, a) = rj + \u03b3max a\n[ rj+1 + \u03b3max\na\u2032\n[ rj+2 + \u03b3max\na\u0303 Q\u2217(sj+3, a\u0303)\n]] .\nEvaluating such a sequence exactly is not possible in a reinforcement learning setting since the enumeration of intermediate states sj+i requires exponential time complexityO(|A|i). It is however possible to take advantage of the episodes available in the replay memory D by noting that the following sequence of inequalities holds for the optimal action-value function Q\u2217 (with the greedy policy), irrespective of whether a policy \u03c0 generating the sequence of actions aj , aj+1, etc., which results in rewards rj , rj+1, etc. is optimal or not:\nQ\u2217(sj , aj) = rj + \u03b3max a Q\u2217(sj+1, a)] \u2265 . . . \u2265 k\u2211 i=0 \u03b3irj+i + \u03b3 k+1 max a Q\u2217(sj+k+1, a) = L \u2217 j,k.\nNote the definition of the lower bounds L\u2217j,k for sample j and time horizon k in the aforementioned series of inequalities.\nWe can also use this series of inequalities to define upper bounds. To see this note that\nQ\u2217(sj\u2212k\u22121, aj\u2212k\u22121)\u2212 k\u2211 i=0 \u03b3irj\u2212k\u22121+i \u2212 \u03b3k+1Q\u2217(sj , aj) \u2265 0,\nwhich follows from the definition of the lower bound by dropping the maximization over the actions, and a change of indices from j \u2192 j \u2212 k \u2212 1. Reformulating the inequality yields an upper bound U\u2217j,k for sample j and time horizon k by fixing state sj and action aj as follows:\nU\u2217j,k = \u03b3 \u2212k\u22121Q\u2217(sj\u2212k\u22121, aj\u2212k\u22121)\u2212 k\u2211 i=0 \u03b3i\u2212k\u22121rj\u2212k\u22121+i \u2265 Q\u2217(sj , aj).\nIn contrast to classical techniques which optimize the Bellman criterion given in Eq. (2), we propose to optimize the Bellman equation subject to constraints Q\u03b8(sj , aj) \u2265 Lmaxj = maxk\u2208{1,...,K} Lj,k, which defines the largest lower bound, and Q\u03b8(sj , aj) \u2264 Uminj = mink\u2208{1,...,K} Uj,k, which specifies the smallest upper bound. Hereby, Lj,k and Uj,k are computed using the Q-function Q\u03b8\u2212 with a recent estimated parameter \u03b8\u2212 rather than the unknown optimal Q-function Q\u2217, and the integer K specifies the number of future and past time steps which are considered. Also note that the target used in the Bellman equation is obtained from yj = Lj,0 = rj + \u03b3maxaQ\u03b8\u2212(sj+1, a). In this way, we ignore the dependence of the bounds and the target on the parameter \u03b8 to stabilize the training. Taking all the aforementioned definitions into account, we propose the following program for\nOutput : Parameters \u03b8 of a Q-function Initialize: \u03b8 randomly, set \u03b8\u2212 = \u03b8 for episode\u2190 1 to M do\ninitialize s1; for t\u2190 1 to T do\nChoose action at according to -greedy strategy; Observe reward rt and next state st+1; Store the tuple (st, at, rt, \u00b7, st+1) in replay memory D; Sample a minibatch of tuples B = {(sj , aj , rj , Rj , sj+1}) from replay memory D; Update \u03b8 with one gradient step of cost function given in Eq. (4); Reset \u03b8\u2212 = \u03b8 every C steps;\nend for t\u2190 T to 1 do\nCompute Rt = rt + \u03b3Rt+1; Insert Rt into the corresponding tuple in replay memory D;\nend end\nAlgorithm 1: Our algorithm for fast reward propagation in reinforcement learning tasks.\nreinforcement learning tasks:\nmin \u03b8 \u2211 (sj ,aj ,sj+1,rj)\u2208B (Q\u03b8(sj , aj)\u2212 yj)2 s.t. { Q\u03b8(sj , aj) \u2265 Lmaxj \u2200 (sj , aj) \u2208 B Q\u03b8(sj , aj) \u2264 Uminj \u2200 (sj , aj) \u2208 B . (3)\nThis program differs from the classical approach given in Eq. (2) via the constraints, which is crucial. Intuitively, the constraints encourage faster reward propagation as we show next, and result in tremendously better results as we will demonstrate empirically in Sec. 5.\nBefore doing so we describe our optimization procedure for the constrained program in Eq. (3) more carefully. The cost function is generally non-convex in the parameters \u03b8, and so are the constraints. We therefore make use of a quadratic penalty method to reformulate the program into\nmin \u03b8 \u2211 (sj ,aj ,rj ,sj+1)\u2208B [ (Q\u03b8(sj , aj)\u2212 yj)2 + \u03bb(Lmaxj \u2212Q\u03b8(sj , aj))2+ + \u03bb(Q\u03b8(sj , aj)\u2212 Uminj )2+ ] , (4)\nwhere \u03bb is a penalty coefficient and (x)+ = max(0, x) is the rectifier function. Augmenting the cost function with \u03bb(Lmaxj \u2212Q\u03b8(sj , aj))2+ and/or \u03bb(Q\u03b8(sj , aj)\u2212Uminj )2+ results in a penalty whenever any optimality bounding constraint gets violated. The quadratic penalty function is chosen for simplicity. The penalty coefficient \u03bb can be set as a large positive value or adjusted in an annealing scheme during training. In this work, we fix its value, due to time constraints. We optimize this cost function with stochastic (sub-)gradient descent using an experience replay memory from which we randomly draw samples, as well as their successors and predecessors. We emphasize that the derivatives correcting the prediction of Q(sj , aj) not only depend on the Q-function from the immediately successive time step Q(sj+1, a) stored in the experience replay memory, but also on more distant time instances if constraints are violated. Our proposed formulation and the resulting optimization technique hence encourage faster reward propagation, and the number of time steps depends on the constant K and the quality of the current Q-function. We summarize the proposed method in Algorithm 1.\nThe computational complexity of the proposed approach increases with the number of considered time steps K, since additional forward passes are required to compute the bounds Lmaxj and U min j . However, we can increase the memory size on the GPU to compute both the bounds and targets in a single forward pass if K is not too large. If at all a problem, we can further alleviate this increase by randomly sampling a subset of the constraints rather than exhaustively using all of them. More informed strategies regarding the choice of constraints are possible as well since we may expect lower bounds in the more distant future to have a larger impact early in the training. In contrast once the algorithm is almost converged we may expect lower bounds close to the considered time-step to have bigger impact.\nTo efficiently compute the discounted reward over multiple time steps we add a new element to the experience replay structure. Specifically, in addition to state, action, reward and next state for\ntime-step j, we also store the real discounted return Rj which is the discounted cumulative return achieved by the agent in its game episode. Rj is computed via Rj = \u2211T \u03c4=j \u03b3\n\u03c4\u2212jr\u03c4 , where T is the end of the episode and \u03b3 is the discount factor. Rj is then inserted in the replay memory after the termination of the current episode or after reaching the limit of steps. All in all, the structure of our experience replay memory consists of tuples of the form (sj , aj , rj , Rj , sj+1). In practice, we also found that incorporating Rj in the lower bound calculation can further improve the stability of the training.\nWe leave the questions regarding a good choice of penalty function and a good choice of the penalty coefficients to future work. At the moment we use a quadratic penalty function and a constant penalty coefficient \u03bb identical for both bounds. More complex penalty functions and sophisticated optimization approaches may yield even better results than the ones we report in the following."}, {"heading": "5 EXPERIMENTS", "text": "We evaluate the proposed algorithm on a set of 49 games from the Arcade Learning Environment (Bellemare et al., 2013) as suggested by Mnih et al. (2015). This environment is considered to be one of the most challenging reinforcement learning task because of its high dimensional output. Moreover, the intrinsic mechanism varies tremendously for each game, making it extremely demanding to find a single, general and robust algorithm and a corresponding single hyperparameter setting which works well across all 49 games.\nFollowing existing work (Mnih et al., 2015), our agent predicts an action based on only raw image pixels and reward information received from the environment. A deep neural network is used as the function approximator for the Q-function. The game image is resized to an 84 \u00d7 84 grayscale image st. The first layer is a convolutional layer with 32 filters of size 8 \u00d7 8 and a stride of 4; the second layer is a convolutional layer with 64 filters of size 4 \u00d7 4 and stride of 2; the third layer is a convolutional layer with 64 filters of size 3 \u00d7 3 and a stride of 1; the next fully connected layer transforms the input to 512 units which are then transformed by another fully connected layer to an output size equal to the number of actions in each game. The rectified linear unit (ReLU) is used as the activation function for each layer. We used the hyperparameters provided by Mnih et al. (2015) for annealing -greedy exploration and also applied RMSProp for gradient descent. As in previous work we combine four frames into a single step for processing. We chose the hyperparamenter K = 4, for GPU memory efficiency when dealing with mini-batches. In addition, we also include the discounted return Rj = Lj,\u221e in the lower bound calculation to further stabilize the training. We use the penalty coefficient \u03bb = 4 which was obtained by coarsely tuning performance on the games \u2018Alien,\u2019 \u2018Amidar,\u2019 \u2018Assault,\u2019 and \u2018Asterix.\u2019 Gradients are also rescaled so that their magnitudes are comparable with or without penalty. All experiments are performed on an NVIDIA GTX Titan-X 12GB graphics card."}, {"heading": "5.1 EVALUATION", "text": "In previous work (Mnih et al., 2015; van Hasselt et al., 2015; Schaul et al., 2016; Wang et al., 2015), the Q-function is trained on each game using 200 million (200M) frames or 50M training steps. We compare to those baseline results obtained after 200M frames using our proposed algorithm which ran for only 10M frames or 2.5M steps, i.e., 20 times fewer data, due to time constraints. Instead of training more than 10 days we manage to finish training in less than one day. Furthermore, for a fair comparison, we replicate the DQN results and compare the performance of the proposed algorithm after 10M frames to those obtained when training DQN on only 10M frames.\nWe strictly follow the evaluation procedure in (Mnih et al., 2015) which is often referred to as \u201830 no-op evaluation.\u2019 During both training and testing, at the start of the episode, the agent always performs a random number of at most 30 no-op actions. During evaluation, our agent plays each game 30 times for up to 5 minutes, and the obtained score is averaged over these 30 runs. An - greedy policy with = 0.05 is used. Specifically, for each run, the game episode starts with at most 30 no-op steps, and ends with \u2018death\u2019 or after a maximum of 5 minute game-play, which corresponds to 18000 frames.\nOur training consists of M = 40 epochs, each containing 250000 frames, thus 10M frames in total. For each game, we evaluate our agent at the end of every epoch, and, following common practice (van Hasselt et al., 2015; Mnih et al., 2015), we select the best agent\u2019s evaluation as the result of the game. So almost all hyperparameters are selected identical to Mnih et al. (2015) and Nair et al. (2015).\nTo compare the performance of our algorithm to the DQN baseline, we follow the approach of Wang et al. (2015) and measure the improvement in percent using\nScoreAgent \u2212 ScoreBaseline max{ScoreHuman,ScoreBaseline} \u2212 ScoreRandom . (5)\nWe select this approach because the denominator choice of either human or baseline score prevents insignificant changes or negative scores from being interpreted as large improvements.\nFig. 1 shows the improvement of our algorithm over the DQN baseline proposed by Mnih et al. (2015) and trained for 200M frames, i.e., 50M steps. Even though our agent is only trained for 10M frames, we observe that our technique outperforms the baseline significantly. In 30 out of 49 games, our algorithm exceeds the baseline using only 5% of the baseline\u2019s training frames, sometimes drastically, e.g., in games such as \u2018Atlantis,\u2019 \u2018Double Dunk,\u2019 and \u2018Krull.\u2019 The remaining 19 games, often require a long training time. Nonetheless, our algorithm still reaches a satisfactory level of performance.\nIn order to further illustrate the effectiveness of our method, we compare our results with our implementation of DQN trained on 10M frames. The results are illustrated in Fig. 2. We observe a better performance on 46 out of 49 games, demonstrating in a fair way the potential of our technique.\nAs suggested by van Hasselt et al. (2015), we use the following score\nScoreNormalized = ScoreAgent \u2212 ScoreRandom |ScoreHuman \u2212 ScoreRandom|\n(6)\nto summarize the performance of our algorithm in a single number. We normalize the scores of our algorithm, the baseline reported by Mnih et al. (2015), and double DQN (D-DQN) (van Hasselt et al., 2015), and report the training time, mean and median in Table 1. We observe our technique with 10M frames to achieve comparable scores to the D-DQN method trained on 200M frames (van Hasselt et al., 2015), while it outperforms the DQN method (Mnih et al., 2015) by a large margin. We believe that our method can be readily combined with other techniques developed for DQN, such as D-DQN (van Hasselt et al., 2015), prioritized experience replay (Schaul et al., 2016), dueling networks (Wang et al., 2015), and asynchronous methods (Mnih et al., 2016) to further improve the accuracy and training speed.\nIn Fig. 3 we illustrate the evolution of the score for our algorithm and the DQN approach. In addition we demonstrate two additional techniques: \u2018DQN+return\u2019 and \u2018DQN(\u03bb).\u2019 \u2018DQN+return\u2019 uses only the discounted future return as a bound, but does not take advantage of the additional constraints we propose. \u2018DQN(\u03bb)\u2019 combines TD-\u03bb with the DQN algorithm. We illustrate the performance of those four algorithms on the six games \u2018Frostbite,\u2019 \u2018Atlantis,\u2019 \u2018Zaxxon,\u2019 \u2018H.E.R.O,\u2019 \u2018Q*Bert,\u2019 and \u2018Chopper Command.\u2019 We observe our method to achieve higher scores than the three baselines on the majority of the games. We refer the reader to the supplementary material for additional results."}, {"heading": "6 CONCLUSION", "text": "In this paper we proposed a novel program for deep Q-learning which propagates promising rewards to achieve significantly faster convergence than the classical DQN. Our method significantly outperforms competing approaches even when trained on a small fraction of the data on the Atari 2600 domain. In the future, we plan to investigate the impact of penalty functions, advanced constrained optimization techniques and explore potential synergy with other techniques."}, {"heading": "A SUPPLEMENTARY MATERIAL", "text": "OPTIMALITY TIGHTENING FOR STOCHASTIC ENVIRONMENTS\nSimilar to the inequalities we obtained for deterministic environments, we can also derive the following sequence of inequalities holds for the optimal action-value function Q\u2217 (with the greedy policy), under the expectation of the environmental dynamics:\nQ\u2217(sj , aj) = E[rj + \u03b3max a Q\u2217(sj+1, a)]\n\u2265 . . .\n\u2265 E[ k\u2211 i=0 \u03b3irj+i + \u03b3 k+1 max a Q\u2217(sj+k+1, a)]\nSo we have the following expectation constraint, on trajectories from state sj and action aj .\nE[Q\u2217(sj , aj)\u2212 ( k\u2211 i=0 \u03b3irj+i + \u03b3 k+1 max a Q\u2217(sj+k+1, a))] \u2265 0\nE[Q\u2217(sj , aj)\u2212 Lj,k] \u2265 0 We can also use this series of inequalities to define upper bounds, on trajectories to state sj and action aj .\nE[Q\u2217(sj , aj)\u2212 (\u03b3\u2212k\u22121Q\u2217(sj\u2212k\u22121, aj\u2212k\u22121)\u2212 k\u2211 i=0 \u03b3i\u2212k\u22121rj\u2212k\u22121+i)] \u2264 0\nE[Q\u2217(sj , aj)\u2212 Uj,k] \u2264 0 With these expectation constraints, we can formulate a constrained optimization problem as follows:\nmin \u03b8 \u2211 (sj ,aj ,sj+1,rj)\u2208B (Q\u03b8(sj , aj)\u2212 yj)2\ns.t. {\nmink E[Q\u03b8(sj , aj)\u2212 Lj,k] \u2265 0 \u2200 (sj , aj) \u2208 B maxk E[Q\u03b8(sj , aj)\u2212 Uj,k] \u2264 0 \u2200 (sj , aj) \u2208 B .\nApplying the quadratic penalty function method, we obtain the objective:\u2211 (sj ,aj ,rj ,sj+1)\u2208B [ (Q\u03b8(sj , aj)\u2212 yj)2 + \u03bb(max k E[Lj,k \u2212Q\u03b8(sj , aj)]2+ +max k E[(Q\u03b8(sj , aj)\u2212 Uj,k)]2+) ] By applying the Jensen\u2019s inequality, we are able to obtain an upper bound by first exchanging the expectation with the max and then exchanging the expectation with the rectifier function, because both the max function and the rectifier function are convex.\u2211 (sj ,aj ,rj ,sj+1)\u2208B [ (Q\u03b8(sj , aj)\u2212 yj)2 + E[\u03bb(max k Lj,k \u2212Q\u03b8(sj , aj)2+] + E[\u03bb(Q\u03b8(sj , aj)\u2212max k Uj,k) 2 +)]\n] It is easy to see that, since we have trajectory samples in the replay memory which were drawn under the environmental dynamics, we can perform stochastic optimization using these trajectories. In this way, a sample of this upper bound is identical to that in the deterministic setting in Eq. (4). As a result, our proposed algorithm can be used to optimize an upper bound of the above constrained optimization in stochastic environments.\nPlease note that here we provide a mathematical derivation of our approach for stochastic environments. We expect that it would work in practice, but due to time constraints and the lack of good stochastic simulators, we cannot provide any empirical results here."}, {"heading": "B ADDITIONAL RESULTS", "text": "We present our quantitative results in Table S1 and Table S2. We also illustrate the normalized score provided in Eq. (6) over the number of episodes in Fig. S1.\nGame Random Human DQN 200M Ours 10M Alien 227.80 6875 3069 1864 Amidar 5.8 1676 739.5 565.67 Assault 222.4 1496 3359 5142.37 Asterix 210 8503 6012 5408.33 Asteroids 719.1 13157 1629 1481.67 Atlantis 12850 29028 85641 316766.67 Bank Heist 14.2 734.4 429.7 596 Battle Zone 2360 37800 26300 30800 Beam Rider 363.9 5775 6846 8069 Bowling 23.1 154.8 42.4 49.3 Boxing 0.1 4.3 71.8 81.17 Breakout 1.7 31.8 401.2 229.79 Centipede 2091 11963 8309 4470.06 Chopper Command 811 9882 6687 6360 Crazy Climber 10781 35411 114103 114146 Demon Attack 152.1 3401 9711 5738.67 Double Dunk -18.6 -15.5 -18.1 -10.07 Enduro 0 309.6 301.8 672.83 Fishing Derby -91.7 5.5 -0.8 5.27 Freeway 0 29.6 30.3 31.3 Frostbite 65.2 4335 328.3 3974.11 Gopher 257.6 2321 8520 4660 Gravitar 173 2672 306.7 346.67 H.E.R.O 1027 25763 19950 19975 Ice Hockey -11.2 0.9 -1.6 -3.43 Jamesbond 29 406.7 576.7 1088.33 Kangaroo 52 3035 6740 11716.67 Krull 1598 2395 3805 9461.1 Kung-Fu Master 258.5 22736 23270 27820 Montezuma\u2019s Revenge 0 4376 0 23.33 Ms. Pacman 307.3 15693 2311 1805 Name This Game 2292 4076 7257 7314.67 Pong -20.7 9.3 18.9 19.4 Private Eye 24.9 69571 1788 342.37 Q*Bert 163.9 13455 10596 12355 River Raid 1339 13513 8316 8028.33 Road Runner 11.5 7845 18257 29346.67 Robotank 2.2 11.9 51.6 34.5 Seaquest 68.4 20182 5286 4070 Space Invaders 148 1652 1976 995 Star Gunner 664 10250 57997 16653.95 Tennis -23.8 -8.9 -2.5 -1 Time Pilot 3568 5925 5947 5423.33 Tutankham 11.4 167.6 186.7 232 Up and Down 533.4 9082 8456 14406 Venture 0 1188 380 286.67 Video Pinball 16257 17298 42684 74873.2 Wizard of Wor 563.5 4757 3393 4716.67 Zaxxon 32.5 9173 4977 10598\nTable S1: Raw Scores across 49 games, using 30 no-op start evaluation (5 minutes emulator time, 18000 frames, = 0.05). Results of DQN is taken from Mnih et al. (2015)\nGame DQN 200M Ours 10M Alien 42.74% 24.62% Amidar 43.93% 33.52% Assault 246.27% 386.31% Asterix 69.96% 62.68% Asteroids 7.32% 6.13% Atlantis 449.94% 1878.60% Bank Heist 57.69% 80.78% Battle Zone 67.55% 80.25% Beam Rider 119.79% 142.39% Bowling 14.65% 19.89% Boxing 1707.14% 1930.24% Breakout 1327.24% 757.77% Centipede 62.99% 24.10% Chopper Command 64.78% 61.17% Crazy Climber 419.50% 419.67% Demon Attack 294.22% 171.95% Double Dunk 16.13% 275.16% Enduro 97.48% 217.32% Fishing Derby 93.52% 99.76% Freeway 102.36% 105.74% Frostbite 6.16% 91.55% Gopher 400.43% 213.36% Gravitar 5.35% 6.95% H.E.R.O 76.50% 76.60% Ice Hockey 79.34% 64.22% Jamesbond 145.00% 280.47% Kangaroo 224.20% 391.04% Krull 276.91% 986.59% Kung-Fu Master 102.38% 122.62% Montezuma\u2019s Revenge 0% 0.53% Ms. Pacman 13.02% 9.73% Name This Game 278.31% 281.54% Pong 132% 133.67% Private Eye 2.54% 0.46% Q*Bert 78.49% 91.73% River Raid 57.31% 54.95% Road Runner 232.92% 374.48% Robotank 509.28% 332.99% Seaquest 25.94% 19.90% Space Invaders 121.54% 56.31% Star Gunner 598.10% 166.81% Tennis 142.95% 153.02% Time Pilot 100.93% 78.72% Tutankham 112.23% 141.23% Up and Down 92.68% 162.38% Venture 31.99% 24.13% Video Pinball 2538.62% 5630.76% Wizard of Wor 67.47% 99.04% Zaxxon 54.09% 115.59%\nTable S2: Normalized results across 49 games, using the evaluation score given in Eq. (6)\nFigure S1: Convergence of mean and median of normalized percentages on 49 games."}], "references": [{"title": "The arcade learning environment: An evaluation platform for general agents", "author": ["M.G. Bellemare", "Y. Naddaf", "J. Veness", "M. Bowling"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Bellemare et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bellemare et al\\.", "year": 2013}, {"title": "Representation Learning: A Review and New Perspectives", "author": ["Y. Bengio", "A. Courville", "P. Vincent"], "venue": null, "citeRegEx": "Bengio et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 2013}, {"title": "ModelFree Episodic Control", "author": ["C. Blundell", "B. Uria", "A. Pritzel", "Y. Li", "A. Ruderman", "J.Z. Leibo", "J. Rae", "D. Wierstra", "D. Hassabis"], "venue": "In http://arxiv.org/pdf/1606.04460v1.pdf,", "citeRegEx": "Blundell et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Blundell et al\\.", "year": 2016}, {"title": "Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups", "author": ["G.E. Hinton", "L. Deng", "D. Yu", "G.E. Dahl", "A.-R. Mohamed", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T.N. Sainath", "B. Kingsbury"], "venue": "IEEE Signal Processing Magazine,", "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "Reinforcement learning: A survey", "author": ["L.P. Kaelbling", "M.L. Littman", "A.W. Moore"], "venue": null, "citeRegEx": "Kaelbling et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Kaelbling et al\\.", "year": 1996}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "In Proc. NIPS,", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Deep auto-encoder neural networks in reinforcement learning", "author": ["S. Lange", "M. Riedmiller"], "venue": "In Proc. Int. Jt. Conf. Neural. Netw.,", "citeRegEx": "Lange and Riedmiller.,? \\Q2010\\E", "shortCiteRegEx": "Lange and Riedmiller.", "year": 2010}, {"title": "Self-improving reactive agents based on reinforcement learning, planning and teaching", "author": ["L.-J. Lin"], "venue": "Machine Learning,", "citeRegEx": "Lin.,? \\Q1992\\E", "shortCiteRegEx": "Lin.", "year": 1992}, {"title": "Playing Atari with Deep Reinforcement Learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A. Graves", "I. Antonoglou", "D. Wierstra", "M. Riedmiller"], "venue": "In NIPS Deep Learning Workshop,", "citeRegEx": "Mnih et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2013}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski", "S. Petersen", "C. Beattie", "A. Sadik", "I. Antonoglou", "H. King", "D. Kumaran", "D. Wierstra", "S. Legg", "D. Hassabis"], "venue": "Nature,", "citeRegEx": "Mnih et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2015}, {"title": "Asynchronous Methods for Deep Reinforcement Learning", "author": ["V. Mnih", "A.P. Badia", "M. Mirza", "A. Graves", "T.P. Lillicrap", "T. Harley", "D. Silver", "K. Kavukcuoglu"], "venue": "In https://arxiv.org/abs/1602.01783,", "citeRegEx": "Mnih et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2016}, {"title": "Safe and efficient off-policy reinforcement learning", "author": ["R. Munos", "T. Stepleton", "A. Harutyunyan", "M.G. Bellemare"], "venue": "In Proc. NIPS,", "citeRegEx": "Munos et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Munos et al\\.", "year": 2016}, {"title": "Massively Parallel Methods for Deep Reinforcement Learning", "author": ["A. Nair", "P. Srinivasan", "S. Blackwell", "C. Alcicek", "R. Fearon", "V. Panneershelvam A. De Maria", "M. Suleyman", "C. Beattie", "S. Petersen", "S. Legg", "V. Mnih", "K. Kavukcuoglu", "D. Silver"], "venue": "In https://arxiv.org/abs/1507.04296,", "citeRegEx": "Nair et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2015}, {"title": "Deep Exploration via Bootstrapped DQN", "author": ["I. Osband", "C. Blundell", "A. Pritzel", "B. Van Roy"], "venue": "In http://arxiv.org/abs/1602.04621,", "citeRegEx": "Osband et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Osband et al\\.", "year": 2016}, {"title": "Approximate Dynamic Programming", "author": ["W.P. Powell"], "venue": null, "citeRegEx": "Powell.,? \\Q2011\\E", "shortCiteRegEx": "Powell.", "year": 2011}, {"title": "Neural fitted Q iteration - first experiences with a data efficient neural reinforcement learning method", "author": ["M. Riedmiller"], "venue": "In Proc. ECML,", "citeRegEx": "Riedmiller.,? \\Q2005\\E", "shortCiteRegEx": "Riedmiller.", "year": 2005}, {"title": "Prioritized Experience Replay", "author": ["T. Schaul", "J. Quan", "I. Antonoglou", "D. Silver"], "venue": "In Proc. ICLR,", "citeRegEx": "Schaul et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Schaul et al\\.", "year": 2016}, {"title": "Mastering the game of Go with deep neural networks and tree search. Nature, 2016", "author": ["D. Silver", "A. Huang", "C.J. Maddison", "A. Guez", "L. Sifre", "G. van den Driessche", "J. Schrittwieser", "I. Antonoglou", "V. Panneershelvam", "M. Lanctot", "S. Dieleman", "D. Grewe", "J. Nham", "N. Kalchbrenner", "I. Sutskever", "T. Lillicrap", "M. Leach", "K. Kavukcuoglu", "T. Graepel", "D. Hassabis"], "venue": null, "citeRegEx": "Silver et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Silver et al\\.", "year": 2016}, {"title": "Sequence to sequence learning with neural networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V. Le"], "venue": "In Proc. NIPS,", "citeRegEx": "Sutskever et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2014}, {"title": "Reinforcement Learning: An Introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": null, "citeRegEx": "Sutton and Barto.,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto.", "year": 1998}, {"title": "Issues in using function approxima- tion for reinforcement learning", "author": ["S. Thrun", "A. Schwartz"], "venue": "In Proc. Connectionist Models Summer School,", "citeRegEx": "Thrun and Schwartz.,? \\Q1993\\E", "shortCiteRegEx": "Thrun and Schwartz.", "year": 1993}, {"title": "An analysis of temporal-difference learning with function approximation", "author": ["J.N. Tsitsiklis", "B. Van Roy"], "venue": null, "citeRegEx": "Tsitsiklis and Roy.,? \\Q1997\\E", "shortCiteRegEx": "Tsitsiklis and Roy.", "year": 1997}, {"title": "Double Q-learning", "author": ["H. van Hasselt"], "venue": "In Proc. NIPS,", "citeRegEx": "Hasselt.,? \\Q2010\\E", "shortCiteRegEx": "Hasselt.", "year": 2010}, {"title": "Deep Reinforcement Learning with Double Q-learning", "author": ["H. van Hasselt", "A. Guez", "D. Silver"], "venue": "In https://arxiv.org/abs/1509.06461,", "citeRegEx": "Hasselt et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hasselt et al\\.", "year": 2015}, {"title": "Dueling Network Architectures for Deep Reinforcement Learning", "author": ["Z. Wang", "T. Schaul", "M. Hessel", "H. van Hasselt", "M. Lanctot", "N. de Freitas"], "venue": "In https://arxiv.org/abs/1511.06581,", "citeRegEx": "Wang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2015}, {"title": "Learning from delayed rewards", "author": ["C.J.C.H. Watkins"], "venue": "PhD thesis,", "citeRegEx": "Watkins.,? \\Q1989\\E", "shortCiteRegEx": "Watkins.", "year": 1989}, {"title": "Real-time reinforcement learning by sequential actor-critics and experience replay", "author": ["P. Wawrzynski"], "venue": "Neural Networks,", "citeRegEx": "Wawrzynski.,? \\Q2009\\E", "shortCiteRegEx": "Wawrzynski.", "year": 2009}], "referenceMentions": [{"referenceID": 5, "context": ", 2015) in computer vision, speech recognition and natural language processing have tremendously improved the performance on challenging tasks, including image processing (Krizhevsky et al., 2012), speech-based translation (Sutskever et al.", "startOffset": 171, "endOffset": 196}, {"referenceID": 18, "context": ", 2012), speech-based translation (Sutskever et al., 2014) and language modeling (Hinton et al.", "startOffset": 34, "endOffset": 58}, {"referenceID": 1, "context": "The core idea of deep learning is to use artificial neural networks to model complex hierarchical or compositional data abstractions and representations from raw input data (Bengio et al., 2013).", "startOffset": 173, "endOffset": 194}, {"referenceID": 14, "context": "Reinforcement learning (Bertsekas & Tsitsiklis, 1996; Powell, 2011; Sutton & Barto, 1998; Kaelbling et al., 1996) studies these problems and algorithms which learn policies to make decisions so as to maximize a reward signal from the environment.", "startOffset": 23, "endOffset": 113}, {"referenceID": 4, "context": "Reinforcement learning (Bertsekas & Tsitsiklis, 1996; Powell, 2011; Sutton & Barto, 1998; Kaelbling et al., 1996) studies these problems and algorithms which learn policies to make decisions so as to maximize a reward signal from the environment.", "startOffset": 23, "endOffset": 113}, {"referenceID": 25, "context": "One of the promising algorithms is Q-learning (Watkins, 1989; Watkins & Dayan, 1992).", "startOffset": 46, "endOffset": 84}, {"referenceID": 15, "context": "Deep reinforcement learning with neural function approximation (Tsitsiklis & Roy, 1997; Riedmiller, 2005; Mnih et al., 2013; 2015), possibly a first attempt to combine deep learning and reinforcement learning, has been proved to be effective on a few problems which classical AI approaches were unable to solve.", "startOffset": 63, "endOffset": 130}, {"referenceID": 8, "context": "Deep reinforcement learning with neural function approximation (Tsitsiklis & Roy, 1997; Riedmiller, 2005; Mnih et al., 2013; 2015), possibly a first attempt to combine deep learning and reinforcement learning, has been proved to be effective on a few problems which classical AI approaches were unable to solve.", "startOffset": 63, "endOffset": 130}, {"referenceID": 9, "context": "Notable examples of deep reinforcement learning include human-level game playing (Mnih et al., 2015) and AlphaGo (Silver et al.", "startOffset": 81, "endOffset": 100}, {"referenceID": 17, "context": "AlphaGo trained its model using a database of game records of advanced players and, in addition, about 30 million self-played game moves (Silver et al., 2016).", "startOffset": 137, "endOffset": 158}, {"referenceID": 0, "context": "We evaluate our proposed approach using the Arcade learning environment (Bellemare et al., 2013) and show that our new strategy outperforms competing techniques in both accuracy and training time on 30 out of 49 games despite being trained with significantly fewer data frames.", "startOffset": 72, "endOffset": 96}, {"referenceID": 8, "context": "There have been a number of approaches improving the stability, convergence and runtime of deep reinforcement learning since deep Q-learning, also known as deep Q-network (DQN), was first proposed (Mnih et al., 2013; 2015).", "startOffset": 197, "endOffset": 222}, {"referenceID": 7, "context": "DQN combined techniques such as deep learning, reinforcement learning and experience replays (Lin, 1992; Wawrzynski, 2009).", "startOffset": 93, "endOffset": 122}, {"referenceID": 26, "context": "DQN combined techniques such as deep learning, reinforcement learning and experience replays (Lin, 1992; Wawrzynski, 2009).", "startOffset": 93, "endOffset": 122}, {"referenceID": 16, "context": "Another notable advance is \u201cprioritized experience replay\u201d (Schaul et al., 2016) or \u201cprioritized sweeping\u201d for deep Q-learning.", "startOffset": 59, "endOffset": 80}, {"referenceID": 24, "context": "The dueling network architecture applies an extra network structure to learn the importance of states and uses advantage functions (Wang et al., 2015).", "startOffset": 131, "endOffset": 150}, {"referenceID": 10, "context": "A distributed version of the deep actor-critic algorithm without experience replay was introduced very recently (Mnih et al., 2016).", "startOffset": 112, "endOffset": 131}, {"referenceID": 2, "context": "The model-free episodic control approach evaluates state-action pairs based on episodic memory using k-nearest neighbors with hashing functions (Blundell et al., 2016).", "startOffset": 144, "endOffset": 167}, {"referenceID": 13, "context": "Bootstrapped deep Q-learning carries out temporally-extended (or deep) exploration, thus leading to much faster learning (Osband et al., 2016).", "startOffset": 121, "endOffset": 142}, {"referenceID": 11, "context": "Note that our program is also different from earlier work on off-policy Q\u2217(\u03bb) algorithms with eligibility traces and n-step Q learning (Munos et al., 2016; Watkins, 1989; Mnih et al., 2016), which have been recently shown to perform poorly when used for training deep Q-networks on Atari games.", "startOffset": 135, "endOffset": 189}, {"referenceID": 25, "context": "Note that our program is also different from earlier work on off-policy Q\u2217(\u03bb) algorithms with eligibility traces and n-step Q learning (Munos et al., 2016; Watkins, 1989; Mnih et al., 2016), which have been recently shown to perform poorly when used for training deep Q-networks on Atari games.", "startOffset": 135, "endOffset": 189}, {"referenceID": 10, "context": "Note that our program is also different from earlier work on off-policy Q\u2217(\u03bb) algorithms with eligibility traces and n-step Q learning (Munos et al., 2016; Watkins, 1989; Mnih et al., 2016), which have been recently shown to perform poorly when used for training deep Q-networks on Atari games.", "startOffset": 135, "endOffset": 189}, {"referenceID": 25, "context": "A well established technique to address the aforementioned reinforcement learning task is Qlearning (Watkins, 1989; Watkins & Dayan, 1992).", "startOffset": 100, "endOffset": 138}, {"referenceID": 15, "context": "While classical methods use linear Q-functions based on a set of hand-crafted features of the state, more recent approaches use nonlinear deep neural networks to automatically mine intermediate features from the state (Riedmiller, 2005; Lange & Riedmiller, 2010; Mnih et al., 2013; 2015).", "startOffset": 218, "endOffset": 287}, {"referenceID": 8, "context": "While classical methods use linear Q-functions based on a set of hand-crafted features of the state, more recent approaches use nonlinear deep neural networks to automatically mine intermediate features from the state (Riedmiller, 2005; Lange & Riedmiller, 2010; Mnih et al., 2013; 2015).", "startOffset": 218, "endOffset": 287}, {"referenceID": 7, "context": "A technique called \u201cexperience replay\u201d (Lin, 1992; Wawrzynski, 2009) encourages this property and quickly emerged as a standard step in the well-known deep Q-learning framework (Mnih et al.", "startOffset": 39, "endOffset": 68}, {"referenceID": 26, "context": "A technique called \u201cexperience replay\u201d (Lin, 1992; Wawrzynski, 2009) encourages this property and quickly emerged as a standard step in the well-known deep Q-learning framework (Mnih et al.", "startOffset": 39, "endOffset": 68}, {"referenceID": 8, "context": "A technique called \u201cexperience replay\u201d (Lin, 1992; Wawrzynski, 2009) encourages this property and quickly emerged as a standard step in the well-known deep Q-learning framework (Mnih et al., 2013; 2015).", "startOffset": 177, "endOffset": 202}, {"referenceID": 8, "context": "(1) combined with an \u201cexperience replay\u201d dataset D results in the following iterative algorithmic procedure (Mnih et al., 2013; 2015): start an episode in the initial state s0; sample a mini-batch of tuples B = {(sj , aj , rj , sj+1)} \u2286 D; compute and fix the targets yj = rj + \u03b3maxaQ\u03b8\u2212(sj+1, a) for each tuple using a recent estimate Q\u03b8\u2212 (the maximization is only considered if sj is not a terminal state); update the Q-function by optimizing the following program w.", "startOffset": 108, "endOffset": 133}, {"referenceID": 0, "context": "We evaluate the proposed algorithm on a set of 49 games from the Arcade Learning Environment (Bellemare et al., 2013) as suggested by Mnih et al.", "startOffset": 93, "endOffset": 117}, {"referenceID": 9, "context": "Following existing work (Mnih et al., 2015), our agent predicts an action based on only raw image pixels and reward information received from the environment.", "startOffset": 24, "endOffset": 43}, {"referenceID": 9, "context": "In previous work (Mnih et al., 2015; van Hasselt et al., 2015; Schaul et al., 2016; Wang et al., 2015), the Q-function is trained on each game using 200 million (200M) frames or 50M training steps.", "startOffset": 17, "endOffset": 102}, {"referenceID": 16, "context": "In previous work (Mnih et al., 2015; van Hasselt et al., 2015; Schaul et al., 2016; Wang et al., 2015), the Q-function is trained on each game using 200 million (200M) frames or 50M training steps.", "startOffset": 17, "endOffset": 102}, {"referenceID": 24, "context": "In previous work (Mnih et al., 2015; van Hasselt et al., 2015; Schaul et al., 2016; Wang et al., 2015), the Q-function is trained on each game using 200 million (200M) frames or 50M training steps.", "startOffset": 17, "endOffset": 102}, {"referenceID": 9, "context": "We strictly follow the evaluation procedure in (Mnih et al., 2015) which is often referred to as \u201830 no-op evaluation.", "startOffset": 47, "endOffset": 66}, {"referenceID": 9, "context": "For each game, we evaluate our agent at the end of every epoch, and, following common practice (van Hasselt et al., 2015; Mnih et al., 2015), we select the best agent\u2019s evaluation as the result of the game.", "startOffset": 95, "endOffset": 140}, {"referenceID": 9, "context": ", 2015), while it outperforms the DQN method (Mnih et al., 2015) by a large margin.", "startOffset": 45, "endOffset": 64}, {"referenceID": 16, "context": ", 2015), prioritized experience replay (Schaul et al., 2016), dueling networks (Wang et al.", "startOffset": 39, "endOffset": 60}, {"referenceID": 24, "context": ", 2016), dueling networks (Wang et al., 2015), and asynchronous methods (Mnih et al.", "startOffset": 26, "endOffset": 45}, {"referenceID": 10, "context": ", 2015), and asynchronous methods (Mnih et al., 2016) to further improve the accuracy and training speed.", "startOffset": 34, "endOffset": 53}], "year": 2017, "abstractText": "We propose a novel training algorithm for reinforcement learning which combines the strength of deep Q-learning with a constrained optimization approach to tighten optimality and encourage faster reward propagation. Our novel technique makes deep reinforcement learning more practical by drastically reducing the training time. We evaluate the performance of our approach on the 49 games of the challenging Arcade Learning Environment, and report significant improvements in both training time and accuracy.", "creator": "TeX"}, "id": "ICLR_2017_151"}