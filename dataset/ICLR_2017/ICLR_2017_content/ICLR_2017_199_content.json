{"name": "ICLR_2017_199.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["SYMBOLIC EXPRESSIONS", "Miltiadis Allamanis", "Pankajan Chanthirasegaran", "Pushmeet Kohli", "Charles Sutton"], "emails": ["m.allamanis@ed.ac.uk", "pankajan.chanthirasegaran@ed.ac.uk", "csutton@ed.ac.uk", "pkohli@microsoft.com"], "sections": [{"heading": "1 INTRODUCTION", "text": "Representing and learning knowledge about the world requires not only learning declarative knowledge about facts but also procedural knowledge, knowledge about how to do things, which can be complex yet difficult to articulate explicitly. The goal of building systems that learn procedural knowledge has motivated many recent architectures for learning representations of algorithms (Graves et al., 2014; Reed & de Freitas, 2016; Kaiser & Sutskever, 2016). These methods generally learn from execution traces of programs (Reed & de Freitas, 2016) or input-output pairs generated from a program (Graves et al., 2014; Kurach et al., 2015; Riedel et al., 2016; Grefenstette et al., 2015; Neelakantan et al., 2015).\nHowever, the recursive abstraction that is central to procedural knowledge is perhaps most naturally represented not by abstract models of computation, as in that work, but by symbolic representations that have syntactic structure, such as logical expressions and source code. One type of evidence for this claim is the simple fact that people communicate algorithms using mathematical formulae and pseudocode rather than Turing machines. Yet, apart from some notable exceptions (Alemi et al., 2016; Piech et al., 2015; Allamanis et al., 2016; Zaremba & Sutskever, 2014), symbolic representations of procedures have received relatively little attention within the machine learning literature as a source of information for representing procedural knowledge.\nIn this paper, we address the problem of learning continuous semantic representations (SEMVECs) of symbolic expressions. The goal is to assign continuous vectors to symbolic expressions in such a way that semantically equivalent, but syntactically diverse expressions are assigned to identical (or\nhighly similar) continuous vectors, when given access to a training set of pairs for which semantic equivalence is known. This is an important but hard problem; learning composable SEMVECs of symbolic expressions requires that we learn about the semantics of symbolic elements and operators and how they map to the continuous representation space, thus encapsulating implicit knowledge about symbolic semantics and its recursive abstractive nature.\nOur work in similar in spirit to the work of Zaremba & Sutskever (2014), who focus on learning expression representations to aid the search for computationally efficient identities. They use recursive neural networks (TREENN)1 (Socher et al., 2012) for modelling homogenous, single-variable polynomial expressions. While they present impressive results, we find that the TREENN model fails when applied to more complex symbolic polynomial and boolean expressions. In particular, in our experiments we find that TREENNs tend to assign similar representations to syntactically similar expressions, even when they are semantically very different. The underlying conceptual problem is how to develop a continuous representation that follows syntax but not too much, that respects compositionality while also representing the fact that a small syntactic change can be a large semantic one.\nTo tackle this problem, we propose a new architecture, called neural equivalence networks (EQNETs). EQNETs learn how syntactic composition recursively composes SEMVECs, like a TREENN, but are also designed to model large changes in semantics as the network progresses up the syntax tree. As equivalence is transitive, we formulate an objective function for training based on equivalence classes rather than pairwise decisions. The network architecture is based on composing residual-like multi-layer networks, which allows more flexibility in modeling the semantic mapping up the syntax tree. To encourage representations within an equivalence class to be tightly clustered, we also introduce a training method that we call subexpression forcing, which uses an autoencoder to force the representation of each subexpression to be predictable from its syntactic neighbors. Experimental evaluation on a highly diverse class of symbolic algebraic and boolean expression types shows that EQNETs dramatically outperform existing architectures like TREENNs and RNNs.\nTo summarize, the main contributions of our work are: (a) We formulate the problem of learning continuous semantic representations (SEMVECs) of symbolic expressions and develop benchmarks for this task. (b) We present neural equivalence networks (EQNETs), a neural network architecture that learns to represent expression semantics onto a continuous semantic representation space and how to perform symbolic operations in this space. (c) We provide an extensive evaluation on boolean and polynomial expressions, showing that EQNETs perform dramatically better than state-of-the-art alternatives. Code and data are available at groups.inf.ed.ac.uk/cup/semvec."}, {"heading": "2 MODEL", "text": "In this work, we are interested in learning semantic, composable representations of mathematical expressions (SEMVEC) and learn to generate identical representations for expressions that are semantically equivalent, i.e. they belong to the same equivalence class. Equivalence is a stronger property than similarity that is habitually learned by neural networks, since equivalence is additionally a transitive relationship.\nProblem Hardness. Finding the equivalence of arbitrary symbolic expressions is a NP-hard problem or worse. For example, if we focus on boolean expressions, reducing an expression to the representation of the false equivalence class amounts to proving its non-satisfiability \u2014 an NPcomplete problem. Of course, we do not expect to circumvent an NP-complete problem with neural networks. A network for solving boolean equivalence would require an exponential number of nodes in the size of the formula if P 6= NP . Instead, our goal is to develop architectures whose inductive biases allow them to efficiently learn to solve the equivalence problems for expressions that are similar to a smaller number of expressions in a given training set. This requires that the network learn identical representations for expressions that may be syntactically different but semantically equivalent and also discriminate between expressions that may be syntactically very similar but are non-equivalent. Appendix A shows a sample of such expressions that illustrate the hardness of this problem.\n1To avoid confusion, we use TREENN for recursive neural networks and retain RNN for recurrent neural networks.\nrc2\nrc1\na\na\nc Combine l\u03040\nrp\nSubexpForce\nrc1\nrc2\nrp r\u0303c1\nr\u0303c2\nr\u0303p Combine\nr\u0303c1\u2013rc1, r\u0303c2\u2013rc2, r\u0303p\u2013rp\nx\u0303 l\u03041\nl\u0304out\n/ \u2016\u00b7\u20162\nSemVec\n(a) Architectural diagram of EQNETs. Example parse tree shown is of the boolean expression (a \u2228 c) \u2227 a.\nCOMBINE (rc0 , . . . , rck , \u03c4n) l\u03040 \u2190 [rc0 , . . . , rck ] l\u03041 \u2190 \u03c3 ( Wi,\u03c4n \u00b7 l\u03040 ) l\u0304out \u2190Wo0,\u03c4n \u00b7 l\u03040 +Wo1,\u03c4n \u00b7 l\u03041 return l\u0304out/\n\u2225\u2225l\u0304out\u2225\u22252 (b) COMBINE of EQNET.\nSUBEXPFORCE (rc0 , . . . , rck , rn, \u03c4n) x\u2190 [rc0 , . . . , rck ] x\u0303\u2190 tanh (Wd \u00b7 tanh (We,\u03c4n \u00b7 [rn,x] \u00b7 n)) x\u0303\u2190 x\u0303 \u00b7 \u2016x\u20162 / \u2016x\u0303\u20162 r\u0303n \u2190 COMBINE(x\u0303, \u03c4n) return \u2212 ( x\u0303>x + r\u0303>n rn\n) (c) Loss function used for subexpression forcing\nFigure 1: EQNET architecture.\nNotation and Framework. We employ the general framework of recursive neural networks (TREENN) (Socher et al., 2012; 2013) to learn to compose subtree representations into a single representation. The TREENNs we consider operate on tree structures of the syntactic parse of a formula. Given a tree T , TREENNs learn distributed representations by recursively computing the representations of its subtrees. We denote the children of a node n as ch(n) which is a (possibly empty) ordered tuple of nodes. We also use par(n) to refer to the parent node of n. Each node in our tree has a type, e.g. a terminal node could be of type \u201ca\u201d referring to the variable a or of type \u201cand\u201d referring to a node of the logical and (\u2227) operation. We refer to the type of a node n as \u03c4n. At a high level, TREENNs retrieve the representation of a tree T rooted at node \u03c1, by invoking TREENET(\u03c1) that returns a vector representation r\u03c1 \u2208 RD, i.e., a SEMVEC, using the function TREENET (current node n)\nif n is not a leaf then rn \u2190 COMBINE(TREENET(c0), . . . , TREENET(ck), \u03c4n), where (c0, . . . , ck) = ch(n) else rn \u2190 LOOKUPLEAFEMBEDDING(\u03c4n)\nreturn rn The general framework of TREENET allows two points of variation, the implementation of LOOKUPLEAFEMBEDDING and COMBINE. The traditional TREENNs (Socher et al., 2013) define LOOKUPLEAFEMBEDDING as a simple lookup operation within a matrix of embeddings and COMBINE as a single-layer neural network. As discussed next, these will both prove to be serious limitations in our setting."}, {"heading": "2.1 NEURAL EQUIVALENCE NETWORKS", "text": "We now define the neural equivalence networks (EQNET) that learn to compose representations of equivalence classes into new equivalence classes (Figure 1a). Our network follows the TREENN architecture, that is, our EQNETs are implemented using the TREENET, so as to model the compositional nature of symbolic expressions. However, the traditional TREENNs (Socher et al., 2013) use a single-layer neural network at each tree node. During our preliminary investigations and in Section 3, we found that single layer networks are not expressive enough to capture many operations, even a simple XOR boolean operator, because representing these operations required high-curvature operations in the continuous semantic representation space. Instead, we turn to multi-layer neural networks. In particular, we define the COMBINE in Figure 1b. This uses a two-layer MLP with a residual-like connection to compute the SEMVEC of each parent node in that syntax tree given that of its children. Each node type \u03c4n, e.g., each logical operator, has a different set of weights. We experimented with deeper networks but this did not yield any improvements. However, as TREENN\nbecome deeper, they suffer from optimization issues, such as diminishing and exploding gradients. This is essentially because of the highly compositional nature of tree structures, where the same network (i.e. the COMBINE non-linear function) is used recursively, causing it to \u201cecho\u201d its own errors and producing unstable feedback loops. We observe this problem even with only two-layer MLPs, as the overall network can become quite deep when using two layers for each node in the syntax tree.\nWe resolve this issues in a few different ways. First, we constrain each SEMVEC to have unit norm. That is, we set LOOKUPLEAFEMBEDDING(\u03c4n) = C\u03c4n/ \u2016C\u03c4n\u20162 , and we normalize the output of the final layer of COMBINE in Figure 1b. The normalization step of l\u0304out and C\u03c4n is somewhat similar to layer normalization (Ba et al., 2016), although applying layer normalization directly did not work for our problem. Normalizing the SEMVECs partially resolves issues with diminishing and exploding gradients, and removes a spurious degree of freedom in the semantic representation. As simple as this modification may seem, we found that it was vital to obtaining effective performance, and all of our multi-layer TREENNs converged to low-performing parameters without it.\nHowever this modification is not sufficient, since the network may learn to map expressions from the same equivalence class to multiple SEMVECs in the continuous space. We alleviate this problem using a method that we call subexpression forcing that guides EQNET to cluster its output to one location per equivalence class. We encode each parent-children tuple [rc0 , . . . , rck , rn] containing the (computed) representations of the children and parent node into a low-dimensional space using a denoising autoencoder. We then seek to minimize the reconstruction error of the child representations (r\u0303c0 , . . . , r\u0303ck ) as well as the reconstructed parent representation r\u0303n that can be computed from the reconstructed children. Thus more formally, we minimize the return value of SUBEXPFORCE in Figure 1c where n is a binary noise vector with \u03ba percent of its elements set to zero. Note that the encoder is specific to the type of \u03c4n. Although our SUBEXPFORCE may seem similar to the recursive autoencoders of Socher et al. (2011) it differs significantly in form and purpose, since it acts as an autoencoder on the whole parent-children representation tuple and the encoding is not used within the computation of the parent representation. In addition, this constraint has two effects. It forces each parent-children tuple to \u201clive\u201d in a low-dimensional space, providing a clustering-like behavior. Second, it implicitly joins distinct locations that belong to the same equivalence class. To illustrate the latter point, imagine two semantically equivalent c\u20320 and c \u2032\u2032 0 child\nnodes of different nodes that have two geometrically distinct representations \u2225\u2225rc\u20320 \u2212 rc\u2032\u20320 \u2225\u22252 and COMBINE(rc\u20320 , . . . ) \u2248 COMBINE(rc\u2032\u20320 , . . . ). In some cases due to the autoencoder noise, the differences between the input tuple x\u2032,x\u2032\u2032 that contain rc\u20320 and rc\u2032\u20320 will be non-existent and the decoder will be forced to predict a single location r\u0303c0 (possibly different from rc\u20320 and rc\u2032\u20320 ). Then, when minimizing the reconstruction error, both rc\u20320 and rc\u2032\u20320 will be attracted to r\u0303c0 and eventually should merge."}, {"heading": "2.2 TRAINING", "text": "We train EQNETs from a dataset of expressions whose semantic equivalence is known. Given a training set T = {T1 . . . TN} of parse trees of expressions, we assume that the training set is partitioned into equivalence classes E = {e1 . . . eJ}. We use a supervised objective similar to classification; the difference between classification and our setting is that whereas standard classification problems consider a fixed set of class labels, in our setting the number of equivalence classes in the training set will vary withN . Given an expression tree T that belongs to the equivalence class ei \u2208 E , we compute the probability\nP (ei|T ) = exp\n( TREENN(T )>qei + bi )\u2211 j exp ( TREENN(T )>qej + bj\n) (1) where qei are model parameters that we can interpret as representations of each equivalence classes that appears in the training class, and bi are bias terms. Note that in this work, we only use information about the equivalence class of the whole expression T , ignoring available information about subexpressions. This is without loss of generality, because if we do know the equivalence class of a subexpression of T , we can simply add that subexpression to the training set. Directly maximizing P (ei|T ) would be bad for EQNET since its unit-normalized outputs cannot achieve high probabilities within the softmax. Instead, we train a max-margin objective that maximizes\nclassification accuracy, i.e.\nLACC(T, ei) = max ( 0, arg max ej 6=ei,ej\u2208E logP (ej |T )\u2212 logP (ei|T ) +m ) (2)\nwhere m > 0 is a scalar margin. And therefore the optimized loss function for a single expression tree T that belongs to equivalence class ei \u2208 E is\nL(T, ei) = LACC(T, ei) + \u00b5 |Q| \u2211 n\u2208Q SUBEXPFORCE(ch(n), n) (3)\nwhere Q = {n \u2208 T : | ch(n)| > 0}, i.e. contains the non-leaf nodes of T and \u00b5 \u2208 (0, 1] a scalar weight. We found that subexpression forcing is counterproductive early in training, before the SEMVECs begin to represent aspects of semantics. So, for each epoch t, we set \u00b5 = 1\u2212 10\u2212\u03bdt with \u03bd \u2265 0. Instead of the supervised objective that we propose, an alternative option for training EQNET would be a Siamese objective (Chopra et al., 2005) that learns about similarities (rather than equivalence) between expressions. In practice, we found the optimization to be very unstable, yielding suboptimal performance. We believe that this has to do with the compositional and recursive nature of the task that creates unstable dynamics and the fact that equivalence is a stronger property than similarity."}, {"heading": "3 EVALUATION", "text": "Datasets. We generate datasets of expressions grouped into equivalence classes from two domains. The datasets from the BOOL domain contain boolean expressions and the POLY datasets contain polynomial expressions. In both domains, an expression is either a variable, a binary operator that combines two expressions, or a unary operator applied to a single expression. When defining equivalence, we interpret distinct variables as referring to different entities in the domain, so that, e.g., the polynomials c \u00b7 (a \u00b7 a+ b) and f \u00b7 (d \u00b7 d+ e) are not equivalent. For each domain, we generate \u201csimple\u201d datasets which use a smaller set of possible operators and \u201cstandard\u201d datasets which use a larger set of more complex operators. We generate each dataset by exhaustively generating all parse trees up to a maximum tree size. All expressions are then simplified into a canonical from in order to determine their equivalence class and are grouped accordingly. Table 1 shows the datasets we generated. We also present in Appendix A some sample expressions. For the polynomial domain, we also generated ONEV-POLY datasets, which are polynomials over a single variable, since they are similar to the setting considered by Zaremba & Sutskever (2014) \u2014 although ONEV-POLY is still a little more general because it is not restricted to homogeneous polynomials. Learning SEMVECs for boolean expressions is already a hard problem; with n boolean variables, there are 22 n\nequivalence classes (i.e. one for each possible truth table). We split the datasets into training, validation and test sets. We create two test sets, one to measure generalization performance on equivalence classes that were seen in the training data (SEENEQCLASS), and one to measure generalization to unseen equivalence classes (UNSEENEQCLASS). It is easiest to describe UNSEENEQCLASS first. To create the UNSEENEQCLASS, we randomly select 20% of all the equivalence classes, and place all of their expressions in the test set. We select equivalence classes only if they contain at least two expressions but less than three times the average number of expressions per equivalence class. We thus avoid selecting very common (and hence trivial to learn) equivalence classes in the testset. Then, to create SEENEQCLASS, we take the remaining 80% of the equivalence classes, and randomly split the expressions in each class into training, validation, SEENEQCLASS test in the proportions 60%\u201315%\u201325%. We provide the datasets online.\nBaselines. To compare the performance of our model, we train the following baselines. TF-IDF: learns a representation given the tokens of each expression (variables, operators and parentheses). This can capture topical/declarative knowledge but is unable to capture procedural knowledge. GRU refers to the token-level gated recurrent unit encoder of Bahdanau et al. (2015) that encodes the token-sequence of an expression into a distributed representation. Stack-augmented RNN refers to the work of Joulin & Mikolov (2015) which was used to learn algorithmic patterns and uses a stack as a memory and operates on the expression tokens. We also include two recursive neural network (TREENN) architectures. The 1-layer TREENN which is the original TREENN also used\nby Zaremba & Sutskever (2014). We also include a 2-layer TREENN, where COMBINE is a classic two-layer MLP without residual connections. This shows the effect of SEMVEC normalization and subexpression forcing.\nHyperparameters. We tune the hyperparameters of the baselines and EQNET using Bayesian optimization (Snoek et al., 2012), optimizing on a boolean dataset with 5 variables and maximum tree size of 7 (not shown in Table 1). We use the average k-NN (k = 1, . . . , 15) statistics (described next) as an optimization metric. The selected hyperparameters are detailed in Appendix C."}, {"heading": "3.1 QUANTITATIVE EVALUATION", "text": "Metric. To evaluate the quality of the learned representations we count the proportion of k nearest neighbors of each expression (using cosine similarity) that belong to the same equivalence class. More formally, given a test query expression q in an equivalence class c we find the k nearest neighbors Nk(q) of q across all expressions, and define the score as\nscorek(q) = |Nk(q) \u2229 c| min(k, |c|) . (4)\nTo report results for a given testset, we simply average scorek(q) for all expressions q in the testset.\nEvaluation. Figure 2 presents the average scorek across the datasets for each model. Table 1 shows score5 of UNSEENEQCLASS for each dataset. Detailed plots can be found in Appendix B. It can be clearly seen that EQNET performs better for all datasets, by a large margin. The only exception is POLY5, where the two-layer TREENN performs better. However, this may have to do with the small size of the dataset. The reader may observe that the simple datasets (containing fewer operations and variables) are easier to learn. Understandably, introducing more variables increases the size of the represented space reducing performance. The tf-idf method performs better in settings where more variables are included, because it captures well the variables and operations used. Similar observations can be made for sequence models. The one and two layer TREENNs have mixed performance; we believe that this has to do with exploding and diminishing gradients due to the deep and highly compositional nature of TREENNs. Although Zaremba & Sutskever (2014) consider a different problem to us, they use data similar to the ONEV-POLY datasets with a traditional TREENN architecture. Our evaluation suggests that EQNETs perform much better within the ONEV-POLY setting.\n\u00ac(c \u2295 (a \u2227 ((a \u2295 c) \u2227 b))) ((c \u2228 (\u00acb))\u21d2 a) \u2227 (a \u21d2 a) ((b \u2295 (\u00acc)) \u2227 b)\u2295 (a \u2228 b)\n((b \u00b7 a)\u2212 a) \u00b7 b a \u2212 ((a + b) \u00b7 a) ((c \u00b7 b) \u00b7 c) \u00b7 a b + ((b \u00b7 b) \u00b7 b)\nFigure 3: Visualization of score5 for all expression nodes for three BOOL10 and four POLY8 test sample expressions using EQNET. The darker the color, the lower the score, i.e. white implies a score of 1 and dark red a score of 0.\nEvaluation of Compositionality. We evaluate whether the EQNETs have successfully learned to compute compositional representations, rather than overfitting to expression trees of a small size. We evaluate this by considering a type of transfer setting, in which we train on simpler datasets, but tested on more complex ones; for example, training on the training set of BOOL5 but testing on the testset of BOOL8. We average over 11 different train-test pairs (full list in Figure 6) and present the results in Figure 2b-i and Figure 2b-ii (note the differences in scale to the two figures on the left). These graphs again show that EQNETs are dramatically better than any of the other methods, and indeed, performance is only a bit worse than in the non-transfer setting.\nImpact of EQNET Components EQNETs differ from traditional TREENNs in two major components, which we analyze here. First, SUBEXPFORCE has a positive impact on performance. When training the network with and without subexpression forcing, on average, the area under the curve (AUC) of the scorek decreases by 16.8% on the SEENEQCLASS and 19.7% on the UNSEENEQCLASS. This difference is smaller in the transfer setting of Figure 2b-i and Figure 2b-ii, where AUC decreases by 8.8% on average. However, even in this setting we observe that SUBEXPFORCE helps more in large and diverse datasets. The second key difference to traditional TREENNs is the output normalization at each layer. Comparing our model to the one-layer and two-layer TREENNs again, we find that output normalization results in important improvements (the two-layer TREENNs have on average 60.9% smaller AUC)."}, {"heading": "3.2 QUALITATIVE EVALUATION", "text": "Table 2 and Table 3 shows expressions whose SEMVEC nearest neighbor is of an expression of another equivalence class. Manually inspecting boolean expressions, we find that EQNET confusions happen more when a XOR or implication operator is involved. In fact, we fail to find any confused expressions for EQNET not involving these operations in BOOL5 and in the top 100 expressions in BOOL10. As expected, tf-idf confuses expressions with others that contain the same operators and\nvariables ignoring order. In contrast, GRU and TREENN tend to confuse expressions with very similar symbolic representation differing in one or two deeply nested variables or operators. In contrast, EQNET tends to confuse fewer expressions (as we previously showed) and the confused expressions tend to be more syntactically diverse and semantically related.\nFigure 3 shows a visualization of score5 for each node in the expression tree. One may see that as EQNET knows how to compose expressions that achieve good score, even if the subexpressions achieve a worse score. This suggests that for common expressions, (e.g. single variables and monomials) the network tends to select a unique location, without merging the equivalence classes or affecting the upstream performance of the network. Larger scale interactive t-SNE visualizations can be found online.\nFigure 4 presents two PCA visualizations of the learned embeddings of simple expressions and their negations/negatives. It can be easily discerned that the black dots and their negations (in red) are easily discriminated in the semantic representation space. Figure 4b shows this property in a very clear manner: left-right discriminates between polynomials with a and \u2212a, top-bottom between polynomials that contain b and \u2212b and the diagonal y = x between c and \u2212c. We observe a similar behavior in Figure 4a for boolean expressions."}, {"heading": "4 RELATED WORK", "text": "Researchers have proposed compilation schemes that can transform any given program or expression to an equivalent neural network (Gruau et al., 1995; Neto et al., 2003; Siegelmann, 1994). One can consider a serialized version of the resulting neural network as a representation of the expression. However, it is not clear how we could compare the serialized representations corresponding to two expressions and whether this mapping preserves semantic distances.\nRecursive neural networks (TREENN) (Socher et al., 2012; 2013) have been successfully used in NLP with multiple applications. Socher et al. (2012) show that TREENNs can learn to compute the values of some simple propositional statements. EQNET\u2019s SUBEXPFORCE may resemble recursive autoencoders (Socher et al., 2011) but differs in form and function, encoding the whole parent-children tuple to force a clustering behavior. In addition, when encoding each expression our architecture does not use a pooling layer but directly produces a single representation for the expression.\nMou et al. (2016) use tree convolutional neural networks to classify code into 106 student submissions tasks. Although their model learns intermediate representations of the student tasks, it is a way of learning task-specific features in the code, rather than of learning semantic representations of programs. Piech et al. (2015) also learn distributed matrix representations of programs from student submissions. However, to learn the representations, they use input and output program states and do not test over program equivalence. Additionally, these representations do not necessarily represent program equivalence, since they do not learn the representations over the exhaustive set of all possible input-output states. Allamanis et al. (2016) learn variable-sized representations of\nsource code snippets to summarize them with a short function-like name. This method aims to learn summarization features in code rather than to learn representations of symbolic expression equivalence.\nMore closely related is the work of Zaremba & Sutskever (2014) who use a recursive neural network (TREENN) to guide the tree search for more efficient mathematical identities, limited to homogeneous single-variable polynomial expressions. In contrast, EQNETs consider at a much wider set of expressions, employ subexpression forcing to guide the learned SEMVECs to better represent equivalence, and do not use search when looking for equivalent expressions. Alemi et al. (2016) use RNNs and convolutional neural networks to detect features within mathematical expressions and speed the search for premise selection during automated theorem proving but do not explicitly account for semantic equivalence. In the future, SEMVECs may find useful applications within this work.\nOur work is also related to recent work on neural network architectures that learn controllers/programs (Gruau et al., 1995; Graves et al., 2014; Joulin & Mikolov, 2015; Grefenstette et al., 2015; Dyer et al., 2015; Reed & de Freitas, 2015; Neelakantan et al., 2015; Kaiser & Sutskever, 2016). In contrast to this work, we do not aim to learn how to evaluate expressions or execute programs with neural network architectures but to learn continuous semantic representations (SEMVECs) of expression semantics irrespectively of how they are syntactically expressed or evaluated."}, {"heading": "5 DISCUSSION & CONCLUSIONS", "text": "In this work, we presented EQNETs, a first step in learning continuous semantic representations (SEMVECs) of procedural knowledge. SEMVECs have the potential of bridging continuous representations with symbolic representations, useful in multiple applications in artificial intelligence, machine learning and programming languages.\nWe show that EQNETs perform significantly better than state-of-the-art alternatives. But further improvements are needed, especially for more robust training of compositional models. In addition, even for relatively small symbolic expressions, we have an exponential explosion of the semantic space to be represented. Fixed-sized SEMVECs, like the ones used in EQNET, eventually limit the capacity that is available to represent procedural knowledge. In the future, to represent more complex procedures, variable-sized representations would seem to be required."}, {"heading": "ACKNOWLEDGMENTS", "text": "This work was supported by Microsoft Research through its PhD Scholarship Programme and the Engineering and Physical Sciences Research Council [grant number EP/K024043/1]. We thank the University of Edinburgh Data Science EPSRC Centre for Doctoral Training for providing additional computational resources."}, {"heading": "A SYNTHETIC EXPRESSION DATASETS", "text": "Below are sample expressions within an equivalence class for the two types of datasets we consider.\nBOOL8 (\u00aca) \u2227 (\u00acb) (\u00aca \u2227 \u00acc) \u2228 (\u00acb \u2227 a \u2227 c) \u2228 (\u00acc \u2227 b) (\u00aca) \u2227 b \u2227 c\na\u00ac((\u00aca)\u21d2 ((\u00aca) \u2227 b)) c\u2295 (((\u00aca)\u21d2 a)\u21d2 b) \u00ac((\u00acb) \u2228 ((\u00acc) \u2228 a)) \u00ac((b \u2228 (\u00ac(\u00aca))) \u2228 b) \u00ac((b\u2295 (b \u2228 a))\u2295 c) ((a \u2228 b) \u2227 c) \u2227 (\u00aca) (\u00aca)\u2295 ((a \u2228 b)\u2295 a) \u00ac((\u00ac(b \u2228 (\u00aca)))\u2295 c) (\u00ac((\u00ac(\u00acb))\u21d2 a)) \u2227 c\n(b\u21d2 (b\u21d2 a)) \u2227 (\u00aca) ((b \u2228 a)\u2295 (\u00acb))\u2295 c) (c \u2227 (c\u21d2 (\u00aca))) \u2227 b ((\u00aca)\u21d2 b)\u21d2 (a\u2295 a) (\u00ac((b\u2295 a) \u2227 a))\u2295 c b \u2227 (\u00ac(b \u2227 (c\u21d2 a)))\nFalse (\u00aca) \u2227 (\u00acb) \u2228 (\u2227c) \u00aca \u2228 b (a\u2295 a) \u2227 (c\u21d2 c) (a\u21d2 (\u00acc))\u2295 (a \u2228 b) a\u21d2 ((b \u2227 (\u00acc)) \u2228 b) (\u00acb) \u2227 (\u00ac(b\u21d2 a)) (a\u21d2 (c\u2295 b))\u2295 b \u00ac(\u00ac((b \u2228 a)\u21d2 b)) b \u2227 ((a \u2228 a)\u2295 a) b\u2295 (a\u21d2 (b\u2295 c)) (\u00aca)\u2295 (\u00ac(b\u21d2 (\u00aca)))\n((\u00acb) \u2227 b)\u2295 (a\u2295 a) (b \u2228 a)\u2295 (x\u21d2 (\u00aca)) b \u2228 (\u00ac((\u00acb) \u2227 a)) c \u2227 ((\u00ac(a\u21d2 a)) \u2227 c) b\u2295 ((\u00aca) \u2228 (c\u2295 b)) \u00ac((a\u21d2 (a\u2295 b)) \u2227 a)\nPOLY8 \u2212a\u2212 c c2 b2c2\n(b\u2212 a)\u2212 (c+ b) (c \u00b7 c) + (b\u2212 b) (b \u00b7 b) \u00b7 (c \u00b7 c) b\u2212 (c+ (b+ a)) ((c \u00b7 c)\u2212 c) + c c \u00b7 (c \u00b7 (b \u00b7 b)) a\u2212 ((a+ a) + c) ((b+ c)\u2212 b) \u00b7 c (c \u00b7 b) \u00b7 (b \u00b7 c) (a\u2212 (a+ a))\u2212 c c \u00b7 (c\u2212 (a\u2212 a)) ((c \u00b7 b) \u00b7 c) \u00b7 b (b\u2212 b)\u2212 (a+ c) c \u00b7 c ((c \u00b7 c) \u00b7 b) \u00b7 b\nc b \u00b7 c b\u2212 c c\u2212 ((c\u2212 c) \u00b7 a) (c\u2212 (b\u2212 b)) \u00b7 b (a\u2212 (a+ c)) + b c\u2212 ((a\u2212 a) \u00b7 c) (b\u2212 (c\u2212 c)) \u00b7 c (a\u2212 c)\u2212 (a\u2212 b) ((a\u2212 a) \u00b7 b) + c (b\u2212 b) + (b \u00b7 c) (b\u2212 (c+ c)) + c\n(c+ a)\u2212 a c \u00b7 ((b\u2212 c) + c) (b\u2212 (c\u2212 a))\u2212 a (a \u00b7 (c\u2212 c)) + c (b \u00b7 c) + (c\u2212 c) b\u2212 ((a\u2212 a) + c)"}, {"heading": "B DETAILED EVALUATION", "text": "Figure 5 presents a detailed evaluation for our k-NN metric for each dataset. Figure 6 shows the detailed evaluation when using models trained on simpler datasets but tested on more complex ones, essentially evaluating the learned compositionality of the models. Figure 9 show how the performance varies across the datasets based on their characteristics. As expected as the number of variables increase, the performance worsens (Figure 9a) and expressions with more complex operators tend to have worse performance (Figure 9b). In contrast, Figure 9c suggests no obvious correlation between performance and the entropy of the equivalence classes within the datasets. The results for UNSEENEQCLASS look very similar and are not plotted here."}, {"heading": "C MODEL HYPERPARAMETERS", "text": "The optimized hyperparameters are detailed in Table 4. All hyperparameters were optimized using the Spearmint (Snoek et al., 2012) Bayesian optimization package. The same range of values was used for all common model hyperparameters.\n5 10\nB O\nO L L5 \u2192\nB O\nO L 8\n5 10\nB O\nO L 5\u2192\nB O\nO L 8\n5 10\nB O\nO L 5\u2192\nB O\nO L 10\n5 10\nP O\nLY 8\u2192\nS IM\nP P\nO LY\n8\n5 10\nS IM\nP P\nO LY\n5\u2192 S\nIM P\nP O\nLY 10\n5 10\nS IM\nP P\nO LY\n8\u2192 S\nIM P\nP O\nLY 10\n5 10\nP O\nLY 5\u2192\nS IM\nP P\nO LY\n10\n5 10\nP O\nLY 8\u2192\nS IM\nP P\nO LY\n10\n5 10\nO N\nE V\n-P O\nLY 10 \u2192\nO N\nE V\n-P O\nLY 13\n5 10\nP O\nLY 8\u2192\nO N\nE V\n-P O\nLY 13\n5 10 0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nP O\nLY 5\u2192\nP O\nLY 8\n(a) SEENEQCLASS evaluation using model trained on simpler datasets. Caption is \u201cmodel trained on\u201d\u2192\u201cTest dataset\u201d.\n5 10\nB O\nO L L5 \u2192\nB O\nO L 8\n5 10\nB O\nO L 5\u2192\nB O\nO L 8\n5 10\nB O\nO L 5\u2192\nB O\nO L 10\n5 10\nP O\nLY 8\u2192\nS IM\nP P\nO LY\n8\n5 10\nS IM\nP P\nO LY\n5\u2192 S\nIM P\nP O\nLY 10\n5 10\nS IM\nP P\nO LY\n8\u2192 S\nIM P\nP O\nLY 10\n5 10\nP O\nLY 5\u2192\nS IM\nP P\nO LY\n10\n5 10\nP O\nLY 8\u2192\nS IM\nP P\nO LY\n10\n5 10\nO N\nE V\n-P O\nLY 10 \u2192\nO N\nE V\n-P O\nLY 13\n5 10\nP O\nLY 8\u2192\nO N\nE V\n-P O\nLY 13\n5 10 0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nP O\nLY 5\u2192\nP O\nLY 8\n(b) Evaluation of compositionality. UNSEENEQCLASS evaluation using model trained on simpler datasets. Caption is \u201cmodel trained on\u201d\u2192\u201cTest dataset\u201d.\ntf-idf GRU StackRNN TreeNN-1Layer TreeNN-2Layer EqNet\nFigure 6: Evaluation of compositionality. Evaluation of scorex (y axis) for x = 1, . . . , 15. The markers are shown every five ticks of the x-axis to make the graph more clear. TREENN refers to the model of Socher et al. (2012)."}], "references": [{"title": "DeepMath\u2013 deep sequence models for premise selection", "author": ["Alex A Alemi", "Francois Chollet", "Geoffrey Irving", "Christian Szegedy", "Josef Urban"], "venue": "arXiv preprint arXiv:1606.04442,", "citeRegEx": "Alemi et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Alemi et al\\.", "year": 2016}, {"title": "A convolutional attention network for extreme summarization of source code", "author": ["Miltiadis Allamanis", "Hao Peng", "Charles Sutton"], "venue": "In ICML,", "citeRegEx": "Allamanis et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Allamanis et al\\.", "year": 2016}, {"title": "Neural machine translation by jointly learning to align and translate", "author": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio"], "venue": "In ICLR,", "citeRegEx": "Bahdanau et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Bahdanau et al\\.", "year": 2015}, {"title": "Learning a similarity metric discriminatively, with application to face verification", "author": ["Sumit Chopra", "Raia Hadsell", "Yann LeCun"], "venue": "In CVPR,", "citeRegEx": "Chopra et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Chopra et al\\.", "year": 2005}, {"title": "Transition-based dependency parsing with stack long short-term memory", "author": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A Smith"], "venue": "In ACL,", "citeRegEx": "Dyer et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dyer et al\\.", "year": 2015}, {"title": "Learning to transduce with unbounded memory", "author": ["Edward Grefenstette", "Karl Moritz Hermann", "Mustafa Suleyman", "Phil Blunsom"], "venue": "In NIPS,", "citeRegEx": "Grefenstette et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Grefenstette et al\\.", "year": 2015}, {"title": "Ratajszczak, and Gilles Wiber", "author": ["Fr\u00e9d\u00e9ric Gruau", "Jean-Yves"], "venue": "A neural compiler. Theoretical Computer Science,", "citeRegEx": "Gruau and Jean.Yves,? \\Q1995\\E", "shortCiteRegEx": "Gruau and Jean.Yves", "year": 1995}, {"title": "Inferring algorithmic patterns with stack-augmented recurrent nets", "author": ["Armand Joulin", "Tomas Mikolov"], "venue": null, "citeRegEx": "Joulin and Mikolov.,? \\Q2015\\E", "shortCiteRegEx": "Joulin and Mikolov.", "year": 2015}, {"title": "Neural GPUs learn algorithms", "author": ["\u0141ukasz Kaiser", "Ilya Sutskever"], "venue": "In ICLR,", "citeRegEx": "Kaiser and Sutskever.,? \\Q2016\\E", "shortCiteRegEx": "Kaiser and Sutskever.", "year": 2016}, {"title": "Neural random-access machines", "author": ["Karol Kurach", "Marcin Andrychowicz", "Ilya Sutskever"], "venue": "arXiv preprint arXiv:1511.06392,", "citeRegEx": "Kurach et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kurach et al\\.", "year": 2015}, {"title": "Convolutional neural networks over tree structures for programming language processing", "author": ["Lili Mou", "Ge Li", "Lu Zhang", "Tao Wang", "Zhi Jin"], "venue": "In AAAI,", "citeRegEx": "Mou et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Mou et al\\.", "year": 2016}, {"title": "Neural programmer: Inducing latent programs with gradient descent", "author": ["Arvind Neelakantan", "Quoc V Le", "Ilya Sutskever"], "venue": null, "citeRegEx": "Neelakantan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neelakantan et al\\.", "year": 2015}, {"title": "Symbolic processing in neural networks", "author": ["Jo\u00e3o Pedro Neto", "Hava T Siegelmann", "J F\u00e9lix Costa"], "venue": "Journal of the Brazilian Computer Society,", "citeRegEx": "Neto et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Neto et al\\.", "year": 2003}, {"title": "Learning program embeddings to propagate feedback on student code", "author": ["Chris Piech", "Jonathan Huang", "Andy Nguyen", "Mike Phulsuksombati", "Mehran Sahami", "Leonidas J Guibas"], "venue": "In ICML,", "citeRegEx": "Piech et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Piech et al\\.", "year": 2015}, {"title": "Programming with a differentiable forth interpreter", "author": ["Sebastian Riedel", "Matko Bo\u0161njak", "Tim Rockt\u00e4schel"], "venue": "arXiv preprint arXiv:1605.06640,", "citeRegEx": "Riedel et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Riedel et al\\.", "year": 2016}, {"title": "Neural programming language", "author": ["Hava T. Siegelmann"], "venue": "In Proceedings of the 12th National Conference on Artificial Intelligence,", "citeRegEx": "Siegelmann.,? \\Q1994\\E", "shortCiteRegEx": "Siegelmann.", "year": 1994}, {"title": "Practical Bayesian optimization of machine learning algorithms", "author": ["Jasper Snoek", "Hugo Larochelle", "Ryan P Adams"], "venue": "In NIPS,", "citeRegEx": "Snoek et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Snoek et al\\.", "year": 2012}, {"title": "Semi-supervised recursive autoencoders for predicting sentiment distributions", "author": ["Richard Socher", "Jeffrey Pennington", "Eric H Huang", "Andrew Y Ng", "Christopher D Manning"], "venue": "In EMNLP,", "citeRegEx": "Socher et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2011}, {"title": "Semantic compositionality through recursive matrix-vector spaces", "author": ["Richard Socher", "Brody Huval", "Christopher D Manning", "Andrew Y Ng"], "venue": "In EMNLP,", "citeRegEx": "Socher et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2012}, {"title": "Recursive deep models for semantic compositionality over a sentiment treebank", "author": ["Richard Socher", "Alex Perelygin", "Jean Y Wu", "Jason Chuang", "Christopher D Manning", "Andrew Y Ng", "Christopher Potts"], "venue": "In EMNLP,", "citeRegEx": "Socher et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2013}, {"title": "Learning to execute", "author": ["Wojciech Zaremba", "Ilya Sutskever"], "venue": "arXiv preprint arXiv:1410.4615,", "citeRegEx": "Zaremba and Sutskever.,? \\Q2014\\E", "shortCiteRegEx": "Zaremba and Sutskever.", "year": 2014}], "referenceMentions": [{"referenceID": 9, "context": "These methods generally learn from execution traces of programs (Reed & de Freitas, 2016) or input-output pairs generated from a program (Graves et al., 2014; Kurach et al., 2015; Riedel et al., 2016; Grefenstette et al., 2015; Neelakantan et al., 2015).", "startOffset": 137, "endOffset": 253}, {"referenceID": 14, "context": "These methods generally learn from execution traces of programs (Reed & de Freitas, 2016) or input-output pairs generated from a program (Graves et al., 2014; Kurach et al., 2015; Riedel et al., 2016; Grefenstette et al., 2015; Neelakantan et al., 2015).", "startOffset": 137, "endOffset": 253}, {"referenceID": 5, "context": "These methods generally learn from execution traces of programs (Reed & de Freitas, 2016) or input-output pairs generated from a program (Graves et al., 2014; Kurach et al., 2015; Riedel et al., 2016; Grefenstette et al., 2015; Neelakantan et al., 2015).", "startOffset": 137, "endOffset": 253}, {"referenceID": 11, "context": "These methods generally learn from execution traces of programs (Reed & de Freitas, 2016) or input-output pairs generated from a program (Graves et al., 2014; Kurach et al., 2015; Riedel et al., 2016; Grefenstette et al., 2015; Neelakantan et al., 2015).", "startOffset": 137, "endOffset": 253}, {"referenceID": 0, "context": "Yet, apart from some notable exceptions (Alemi et al., 2016; Piech et al., 2015; Allamanis et al., 2016; Zaremba & Sutskever, 2014), symbolic representations of procedures have received relatively little attention within the machine learning literature as a source of information for representing procedural knowledge.", "startOffset": 40, "endOffset": 131}, {"referenceID": 13, "context": "Yet, apart from some notable exceptions (Alemi et al., 2016; Piech et al., 2015; Allamanis et al., 2016; Zaremba & Sutskever, 2014), symbolic representations of procedures have received relatively little attention within the machine learning literature as a source of information for representing procedural knowledge.", "startOffset": 40, "endOffset": 131}, {"referenceID": 1, "context": "Yet, apart from some notable exceptions (Alemi et al., 2016; Piech et al., 2015; Allamanis et al., 2016; Zaremba & Sutskever, 2014), symbolic representations of procedures have received relatively little attention within the machine learning literature as a source of information for representing procedural knowledge.", "startOffset": 40, "endOffset": 131}, {"referenceID": 18, "context": "They use recursive neural networks (TREENN)1 (Socher et al., 2012) for modelling homogenous, single-variable polynomial expressions.", "startOffset": 45, "endOffset": 66}, {"referenceID": 18, "context": "We employ the general framework of recursive neural networks (TREENN) (Socher et al., 2012; 2013) to learn to compose subtree representations into a single representation.", "startOffset": 70, "endOffset": 97}, {"referenceID": 19, "context": "The traditional TREENNs (Socher et al., 2013) define LOOKUPLEAFEMBEDDING as a simple lookup operation within a matrix of embeddings and COMBINE as a single-layer neural network.", "startOffset": 24, "endOffset": 45}, {"referenceID": 19, "context": "However, the traditional TREENNs (Socher et al., 2013) use a single-layer neural network at each tree node.", "startOffset": 33, "endOffset": 54}, {"referenceID": 3, "context": "Instead of the supervised objective that we propose, an alternative option for training EQNET would be a Siamese objective (Chopra et al., 2005) that learns about similarities (rather than equivalence) between expressions.", "startOffset": 123, "endOffset": 144}, {"referenceID": 16, "context": "We tune the hyperparameters of the baselines and EQNET using Bayesian optimization (Snoek et al., 2012), optimizing on a boolean dataset with 5 variables and maximum tree size of 7 (not shown in Table 1).", "startOffset": 83, "endOffset": 103}, {"referenceID": 12, "context": "4 RELATED WORK Researchers have proposed compilation schemes that can transform any given program or expression to an equivalent neural network (Gruau et al., 1995; Neto et al., 2003; Siegelmann, 1994).", "startOffset": 144, "endOffset": 201}, {"referenceID": 15, "context": "4 RELATED WORK Researchers have proposed compilation schemes that can transform any given program or expression to an equivalent neural network (Gruau et al., 1995; Neto et al., 2003; Siegelmann, 1994).", "startOffset": 144, "endOffset": 201}, {"referenceID": 18, "context": "Recursive neural networks (TREENN) (Socher et al., 2012; 2013) have been successfully used in NLP with multiple applications.", "startOffset": 35, "endOffset": 62}, {"referenceID": 17, "context": "EQNET\u2019s SUBEXPFORCE may resemble recursive autoencoders (Socher et al., 2011) but differs in form and function, encoding the whole parent-children tuple to force a clustering behavior.", "startOffset": 56, "endOffset": 77}, {"referenceID": 5, "context": "Our work is also related to recent work on neural network architectures that learn controllers/programs (Gruau et al., 1995; Graves et al., 2014; Joulin & Mikolov, 2015; Grefenstette et al., 2015; Dyer et al., 2015; Reed & de Freitas, 2015; Neelakantan et al., 2015; Kaiser & Sutskever, 2016).", "startOffset": 104, "endOffset": 292}, {"referenceID": 4, "context": "Our work is also related to recent work on neural network architectures that learn controllers/programs (Gruau et al., 1995; Graves et al., 2014; Joulin & Mikolov, 2015; Grefenstette et al., 2015; Dyer et al., 2015; Reed & de Freitas, 2015; Neelakantan et al., 2015; Kaiser & Sutskever, 2016).", "startOffset": 104, "endOffset": 292}, {"referenceID": 11, "context": "Our work is also related to recent work on neural network architectures that learn controllers/programs (Gruau et al., 1995; Graves et al., 2014; Joulin & Mikolov, 2015; Grefenstette et al., 2015; Dyer et al., 2015; Reed & de Freitas, 2015; Neelakantan et al., 2015; Kaiser & Sutskever, 2016).", "startOffset": 104, "endOffset": 292}], "year": 2017, "abstractText": "The question of how procedural knowledge is represented and inferred is a fundamental problem in machine learning and artificial intelligence. Recent work on program induction has proposed neural architectures, based on abstractions like stacks, Turing machines, and interpreters, that operate on abstract computational machines or on execution traces. But the recursive abstraction that is central to procedural knowledge is perhaps most naturally represented by symbolic representations that have syntactic structure, such as logical expressions and source code. Combining abstract, symbolic reasoning with continuous neural reasoning is a grand challenge of representation learning. As a step in this direction, we propose a new architecture, called neural equivalence networks, for the problem of learning continuous semantic representations of mathematical and logical expressions. These networks are trained to represent semantic equivalence, even of expressions that are syntactically very different. The challenge is that semantic representations must be computed in a syntax-directed manner, because semantics is compositional, but at the same time, small changes in syntax can lead to very large changes in semantics, which can be difficult for continuous neural architectures. We perform an exhaustive evaluation on the task of checking equivalence on a highly diverse class of symbolic algebraic and boolean expression types, showing that our model significantly outperforms existing architectures.", "creator": "LaTeX with hyperref package"}, "id": "ICLR_2017_199"}